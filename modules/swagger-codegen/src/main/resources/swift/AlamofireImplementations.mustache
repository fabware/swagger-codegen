// AlamofireImplementations.swift
//
// Generated by swagger-codegen
// https://github.com/swagger-api/swagger-codegen
//

import Alamofire

class AlamofireRequestBuilderFactory: RequestBuilderFactory {
    func getBuilder<T>() -> RequestBuilder<T>.Type {
        return AlamofireRequestBuilder<T>.self
    }
}

public class GRPCStatus: JSONEncodable {
    public var errorDescription: String?
    public var code: Int?
    var isError: Bool {
        if self.code != 0 {
            print("GRPC status is error: \(self.errorDescription) \(self.code)")
            return true
        } else {
            // print("GRPC status is not error: \(self.errorDescription) \(self.code)")
            return false
        }
    }
    var error: GRPCError? {
        if self.isError {
            return GRPCError.fromGRPC(self.code)
        } else {
            return nil
        }
    }

    public init() {}

    // MARK: JSONEncodable
    func encodeToJSON() -> AnyObject {
        var nillableDictionary = [String:AnyObject?]()
        nillableDictionary["Error"] = self.errorDescription
        nillableDictionary["Code"] = self.code
        let dictionary: [String:AnyObject] = APIHelper.rejectNil(nillableDictionary) ?? [:]
        return dictionary
    }
}

enum GRPCError: Int, ErrorType, CustomStringConvertible {
    case Ok = 0
    case Canceled = 1
    case Unknown = 2
    case InvalidArgument = 3
    case DeadlineExceeded = 4
    case NotFound = 5
    case AlreadyExists = 6
    case PermissionDenied = 7
    case ResourceExhausted = 8
    case FailedPrecondition = 9
    case Aborted = 10
    case OutOfRange = 11
    case Unimplemented = 12
    case Internal = 13
    case Unavailable = 14
    case DataLoss = 15
    case Unauthenticated = 16
    case ConnectFailed = -1004
    case ConnectionLost = -1005

    static func fromGRPC(rawValue: Int?) -> GRPCError? {
        if (rawValue == nil) {
            return nil
        } else {
            if rawValue > GRPCError.Unauthenticated.rawValue {
                return GRPCError(rawValue: 2)
            } else {
                return GRPCError(rawValue: rawValue!)
            }
        }
    }

    static func fromNSError(error: NSError?) -> GRPCError? {
        var codeMap: [Int: GRPCError] = [404: .NotFound,
                                         -1011: .NotFound,
                                         500: .Internal,
                                         -1004: .ConnectFailed,
                                         -1005: .ConnectionLost,
                                         -1001: .DeadlineExceeded,
                                         -6003: .Unauthenticated
                                         ]
        var httpCodeMap: [Int: GRPCError] = [401: .Unauthenticated,
                                             403: .PermissionDenied,
                                             400: .InvalidArgument,
                                             500: .Internal,
                                             502: .Unavailable,
                                             503: .Unavailable]
        if let error = error {
            if codeMap.keys.contains(error.code) {
                let masterError = codeMap[error.code]
                let parts = error.localizedFailureReason?.componentsSeparatedByString(":")
                var rawHttpCode: Int? = 0
                if parts != nil && parts!.count == 2 {
                    rawHttpCode = Int(parts![1].stringByReplacingOccurrencesOfString(" ", withString: ""))
                }
                if rawHttpCode != nil {
                    let err = httpCodeMap[rawHttpCode!]
                    if err != nil {
                        print("Warning: network error \(error) convert http error to GRPC error: \(err)")
                        return err
                    }
                }
                print("Warning: network error \(error) convert to GRPC error: \(masterError)")
                return masterError
            } else {
                print("Warning: unknown network error \(error) convert to GRPC error: UNKNOWN")
                return GRPCError.Unknown
            }
        } else {
            return nil
        }
    }

    var description: String {
        switch self {
        case .Ok:
            return "服务器正常"
        case .Canceled:
            return "服务器取消"
        case .Unknown:
            return "未知服务器错误"
        case .InvalidArgument:
            return "服务器参数错误"
        case .DeadlineExceeded:
            return "服务器超时"
        case .NotFound:
            return "服务器对象不存在"
        case .AlreadyExists:
            return "服务器对象已经存在"
        case .PermissionDenied:
            return "服务器权限不足"
        case .Unauthenticated:
            return "登录失效"
        case .ResourceExhausted:
            return "服务器资源耗竭"
        case .FailedPrecondition:
            return "服务器没有满足前提条件"
        case .Aborted:
            return "服务器取消"
        case .OutOfRange:
            return "服务器超过范围"
        case .Unimplemented:
            return "服务器未实现"
        case .Internal:
            return "服务器内部错误"
        case .Unavailable:
            return "服务器不可用"
        case .DataLoss:
            return "服务器数据丢失"

        case .ConnectFailed:
            return "无法连接服务器"
        case .ConnectionLost:
            return "失去服务器连接"
        }
    }
}

// Store manager to retain its reference
private var managerStore: [String: Alamofire.Manager] = [:]

class AlamofireRequestBuilder<T>: RequestBuilder<T> {
    required init(method: String, URLString: String, parameters: [String : AnyObject]?, isBody: Bool) {
        super.init(method: method, URLString: URLString, parameters: parameters, isBody: isBody)

        Decoders.addDecoder(clazz: GRPCStatus.self) { (source: AnyObject) -> GRPCStatus in
            let sourceDictionary = source as! [NSObject:AnyObject]
            let instance = GRPCStatus()
            instance.errorDescription = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Error"])
            instance.code = Decoders.decodeOptional(clazz: Int.self, source: sourceDictionary["Code"])
            return instance
        }
        
        Decoders.addDecoder(clazz: ResponseStatus.self) { (source: AnyObject) -> ResponseStatus in
            let sourceDictionary = source as! [NSObject:AnyObject]
            let status = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["status"])
            var instance = ResponseStatus(code: "Success")
            if status != nil {
                instance = ResponseStatus(code: status!)
            }
            if let statusDescription = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["statusDescription"]) {
                instance.rawDescription =  statusDescription
            } else {
                instance.rawDescription = ""
            }
            return instance
        }
    }

    override func execute(completion: (response: Response<T>?, error: ErrorType?) -> Void) {
        let managerId = NSUUID().UUIDString
        // Create a new manager for each request to customize its request header
        let configuration = NSURLSessionConfiguration.defaultSessionConfiguration()
        configuration.HTTPAdditionalHeaders = buildHeaders()
        configuration.timeoutIntervalForRequest = kAPIRequestTimeout
        configuration.timeoutIntervalForResource = kAPIResourceTimeout
        let manager = Alamofire.Manager(configuration: configuration)
        managerStore[managerId] = manager

        let encoding = isBody ? Alamofire.ParameterEncoding.JSON : Alamofire.ParameterEncoding.URL
        let xMethod = Alamofire.Method(rawValue: method)
        let fileKeys = parameters == nil ? [] : parameters!.filter { $1.isKindOfClass(NSURL) }
                                                           .map { $0.0 }

        if fileKeys.count > 0 {
            manager.upload(
                xMethod!, URLString, headers: nil,
                multipartFormData: { mpForm in
                    for (k, v) in self.parameters! {
                        switch v {
                        case let fileURL as NSURL:
                            mpForm.appendBodyPart(fileURL: fileURL, name: k)
                            break
                        case let string as NSString:
                            mpForm.appendBodyPart(data: string.dataUsingEncoding(NSUTF8StringEncoding)!, name: k)
                            break
                        case let number as NSNumber:
                            mpForm.appendBodyPart(data: number.stringValue.dataUsingEncoding(NSUTF8StringEncoding)!, name: k)
                            break
                        default:
                            fatalError("Unprocessable value \(v) with key \(k)")
                            break
                        }
                    }
                },
                encodingMemoryThreshold: Manager.MultipartFormDataEncodingMemoryThreshold,
                encodingCompletion: { encodingResult in
                    switch encodingResult {
                    case .Success(let upload, _, _):
                        self.processRequest(upload, managerId, completion)
                    case .Failure(let encodingError):
                        completion(response: nil, error: encodingError)
                    }
                }
            )
        } else {
            processRequest(manager.request(xMethod!, URLString, parameters: parameters, encoding: encoding), managerId, completion)
        }

    }

    private func processRequest(request: Request, _ managerId: String, _ completion: (response: Response<T>?, error: ErrorType?) -> Void) {
        if let credential = self.credential {
            request.authenticate(usingCredential: credential)
        }

        request.validate().responseJSON(options: .AllowFragments) { response in
            managerStore.removeValueForKey(managerId)

            if response.result.isFailure {
                completion(response: nil, error: GRPCError.fromNSError(response.result.error))
                return
            }

            if () is T {
                completion(response: Response(response: response.response!, body: () as! T), error: nil)
                return
            }
            if let json: AnyObject = response.result.value {
                let body = Decoders.decode(clazz: T.self, source: json)
                let grpcStatus = Decoders.decode(clazz: GRPCStatus.self, source: json)
                if grpcStatus.isError {
                    completion(response: Response(response: response.response!, body: body), error: grpcStatus.error)
                    return
                } else {
                    let responseStatus = Decoders.decode(clazz: ResponseStatus.self, source: json)
                    if responseStatus.isOK {
                        completion(response: Response(response: response.response!, body: body), error: nil)
                    } else {
                        completion(response: Response(response: response.response!, body: body), error: responseStatus)
                    }
                    return
                }
            } else if "" is T {
                // swagger-parser currently doesn't support void, which will be fixed in future swagger-parser release
                // https://github.com/swagger-api/swagger-parser/pull/34
                completion(response: Response(response: response.response!, body: "" as! T), error: nil)
                return
            }

            completion(response: nil, error: NSError(domain: "localhost", code: 500, userInfo: ["reason": "unreacheable code"]))
        }
    }

    private func buildHeaders() -> [String: AnyObject] {
        var httpHeaders = Manager.defaultHTTPHeaders
        for (key, value) in self.headers {
            httpHeaders[key] = value
        }
        return httpHeaders
    }
}
